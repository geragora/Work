import pandas as pd
import streamlit as st
import yfinance as yf
import plotly_express as px
import plotly.graph_objects as go
from datetime import timedelta, datetime, date
import numpy as np

data_BTC_USD = yf.download("BTC-USD", start='2023-01-01', end='2024-01-01').Open
data_BTC_RUB = yf.download("BTC-RUB", start='2023-01-01', end='2024-01-01').Open

data_RUB_USD = yf.download("RUBUSD=X", start='2023-01-01', end='2024-01-01').Open
data_RUB_USD = pd.Series(index=data_BTC_USD.index, data=data_RUB_USD)
data_RUB_USD = data_RUB_USD.ffill()
data_RUB_USD = data_RUB_USD.bfill()

data_USD_RUB = yf.download("USDRUB=X", start='2023-01-01', end='2024-01-01').Open
data_USD_RUB = pd.Series(index=data_BTC_USD.index, data=data_USD_RUB)
data_USD_RUB = data_USD_RUB.ffill()
data_USD_RUB = data_USD_RUB.bfill()

data_USD_BTC = 1 / data_BTC_USD
data_RUB_BTC = 1 / data_BTC_RUB

strategies = ['Максимум', 'Минимум', 'Бездействие', 'Пользователь']
cols = ['BTC', 'USD', 'RUB', 'Капитал RUB', 'Капитал USD', 'Капитал BTC']
currencies = ['BTC', 'USD', 'RUB']
cash_in = {'RUB': 500000, 'USD': 4000, 'BTC': 1}
capital = {currency: 0 for currency in currencies}
colors = {'RUB': 'red', 'USD': 'green', 'BTC': 'yellow'}

st.write('СТАРТОВЫЙ КАПИТАЛ:', pd.DataFrame(cash_in, index=['Количество']))
strategy = st.multiselect('Стратегия:', strategies, default=strategies)
c = st.selectbox('Валюта:', currencies)

fig = px.line()

for currency in cols:

    result = pd.DataFrame(index=data_BTC_USD.index.strftime('%Y-%m-%d'), columns=cols, data=cash_in)

for curr_out in currencies:
    for curr_in in currencies:
        if curr_out == curr_in:
            capital[curr_in] += cash_in[curr_out]
        else:
            exchange_rate = globals()[f'data_{curr_out}_{curr_in}']
            capital[curr_in] += cash_in[curr_out] * exchange_rate

for currency in currencies:
    result[f'Капитал {currency}'] = capital[currency]

result = result.ffill()
result = result.bfill()

user_story = result.copy()


def max_min(money, currencies, currx, strategy):

    df = pd.DataFrame(index=data_BTC_USD.index, columns=list(money.columns))
    df.iloc[0] = money.iloc[0]

    pct = pd.DataFrame(index=data_BTC_USD.index, columns=currencies, data={'RUB': 0, 'USD': 0, 'BTC': 0})
    pct.iloc[0] = 0

    for i in range(0, len(data_BTC_USD.index) - 1):
        for cur in currencies:
            pct[cur].iloc[i + 1] = (money[f'Капитал {cur}'].iloc[i + 1] - money[f'Капитал {cur}'].iloc[i]) / \
                                   money[f'Капитал {cur}'].iloc[i]

            if np.all(pct < 0):
                df[f'Капитал {cur}'].iloc[i + 1] = df[f'Капитал {cur}'].iloc[i]
            else:
                if strategy == 'Минимум':
                    percentage_col = pct.iloc[i].idxmin()
                elif strategy == 'Максимум':
                    percentage_col = pct.iloc[i].idxmax()

                if cur == percentage_col:
                    df[f'Капитал {cur}'].iloc[i + 1] = df[f'Капитал {cur}'].iloc[i] * (1 + pct[percentage_col].iloc[i])
                else:
                    exchange_rate = globals()[f'data_{percentage_col}_{cur}'].iloc[0]
                    df[f'Капитал {cur}'].iloc[i + 1] = df[f'Капитал {percentage_col}'].iloc[i] * exchange_rate

    fig.add_scatter(x=data_BTC_USD.index, y=df[f'Капитал {currx}'] / df[f'Капитал {currx}'].iloc[0],
                    mode='lines', name=strategy, line=dict(color='red' if strategy == 'Максимум' else 'blue'))

    return fig


def inaction(money, currx):

    fig.add_trace(go.Scatter(x=data_BTC_USD.index, y=money[f'Капитал {currx}'] /
                            money[f'Капитал {currx}'].iloc[0], mode='lines', name='Бездействие',
                             line=dict(color='grey')))

    return fig


def user_in_out(money, tr_date: str, currx, tr_type, cash_amount):

    cap = {currency: 0 for currency in currencies}

    if tr_type in ['Снять', 'Пополнить']:

        money.loc[tr_date:, currx] += (-1) ** (tr_type == 'Снять') * cash_amount
        cash_in_here = dict(money.loc[tr_date, money.columns[:3]])

        for cur_out in currencies:
            for cur_in in currencies:
                if cur_out == cur_in:
                    cap[cur_in] += cash_in_here[cur_out]
                else:
                    exchange_rate = globals()[f'data_{cur_out}_{cur_in}']
                    cap[cur_in] += cash_in_here[cur_out] * exchange_rate

        for currency in currencies:
            money.loc[tr_date:, f'Капитал {currency}'] = cap[currency]

    money = money.bfill()

    operations = [date(2023, 3, 12), date(2023, 3, 18), date(2023, 4, 19),
                  date(2023, 5, 8), date(2023, 7, 1), date(2024, 1, 1)]

    for i in range(len(operations) - 1):

        mean = money[f'Капитал {c}'].loc[str(operations[i] - timedelta(days=1))] / money[f'Капитал {c}'].iloc[0]
        ch = money[f'Капитал {c}'].loc[str(operations[i])] / money[f'Капитал {c}'].iloc[0]

        fig.add_shape(
            dict(
                type='line',
                x0=str(operations[i]),
                x1=str(operations[i]),
                y0=mean,
                y1=ch,
                yref='y',
                line=dict(color='white', dash='dash')
            )
        )

    return money


def user_convert(money, tr_date: str, tr_type, cash_amount, cur_out, cur_in):

    cap = {currency: 0 for currency in currencies}

    if tr_type == 'Конвертировать':

        exchange_rate = globals()[f'data_{cur_out}_{cur_in}']
        money.loc[tr_date:, cur_out] -= cash_amount
        money.loc[tr_date:, cur_in] = money.loc[tr_date, cur_in] + cash_amount * exchange_rate

    cash_in_here = dict(money.loc[tr_date, money.columns[:3]])

    for cur_out in currencies:
        for cur_in in currencies:
            if cur_out == cur_in:
                cap[cur_in] += cash_in_here[cur_out]
            else:
                exchange_rate = globals()[f'data_{cur_out}_{cur_in}']
                cap[cur_in] += cash_in_here[cur_out] * exchange_rate

    for currency in currencies:
        money.loc[tr_date:, f'Капитал {currency}'] = cap[currency]

    money = money.bfill()
    money = money.ffill()

    return money


def user_story_graph(money, currx):

    user_in_out(user_story, '2023-03-12', 'BTC', 'Снять', 0.8)
    # user_in_out(, '2023-03-12', 'BTC', 'Снять', 0.8)
    # user_in_out(, '2023-03-12', 'BTC', 'Снять', 0.8)

    user_in_out(user_story, '2023-03-18', 'RUB', 'Снять', 40000)
    # user_in_out(user_story, '2023-03-18', 'RUB', 'Снять', 40000)
    # user_in_out(maximum, '2023-03-18', 'RUB', 'Снять', 40000)

    user_in_out(user_story, '2023-04-19', 'USD', 'Пополнить', 35000)
    # user_in_out(minimum, '2023-04-19', 'USD', 'Пополнить', 35000)
    # user_in_out(maximum, '2023-04-19', 'USD', 'Пополнить', 35000)

    user_in_out(user_story, '2023-05-08', 'BTC', 'Пополнить', 0.96)
    # user_in_out(minimum, '2023-05-08', 'BTC', 'Пополнить', 0.96)
    # user_in_out(maximum, '2023-05-08', 'BTC', 'Пополнить', 0.96)

    user_convert(user_story, '2023-06-01', 'Конвертировать', 0.27, 'BTC', 'USD')

    user_in_out(user_story, '2023-07-01', 'BTC', 'Пополнить', 0.12)
    # user_in_out(minimum, '2023-07-01', 'BTC', 'Пополнить', 0.12)
    # user_in_out(maximum, '2023-07-01', 'BTC', 'Пополнить', 0.12)

    user_convert(user_story, '2023-10-01', 'Конвертировать', 20000, 'RUB', 'USD')

    operations = [date(2023, 1, 1), date(2023, 3, 12), date(2023, 3, 18), date(2023, 4, 19),
                  date(2023, 5, 8), date(2023, 7, 1), date(2024, 1, 1)]

    for i in range(len(operations) - 1):

        fig.add_trace(go.Scatter(x=money.loc[str(operations[i]): str(operations[i + 1] - timedelta(days=1))].index,
                                 y=money.loc[str(operations[i]): str(operations[i + 1] - timedelta(days=1)), f'Капитал {currx}']
                                / money[f'Капитал {currx}'].iloc[0], showlegend=False, line=dict(color='white'), mode='lines'))
    fig.add_trace(go.Scatter(name='Пользователь'))

    return fig


if c in currencies:
    if 'Минимум' in strategy:
        max_min(result, currencies, c, 'Минимум')
    if 'Максимум' in strategy:
        max_min(result, currencies, c, 'Максимум')
    if 'Бездействие' in strategy:
        inaction(result, c)
    if 'Пользователь' in strategy:
        user_story_graph(user_story, c)

st.plotly_chart(fig)

